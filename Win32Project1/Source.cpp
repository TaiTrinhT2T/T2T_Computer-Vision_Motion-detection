//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
using namespace cv;
using namespace std;
// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat matBackground;
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
char keyboard; //input from keyboard
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);

int _threshold;
double _alpha;

Mat src_gray;
// Mat drawing;
int thresh = 100;
int max_thresh = 255;

int IndexOfBiggestContour;

Mat createGrayMat(Mat mat)
{
	for (int i = 0; i < mat.rows; ++i) {
		for (int j = 0; j < mat.cols; ++j) {
			Vec3b& rgb = mat.at<Vec3b>(i, j);
			int gray = (2 * rgb[0] + 5 * rgb[1] + 1 * rgb[2]) / 8;

			rgb[0] = rgb[1] = rgb[2] = gray;
		}
	}
	return mat;
}

Mat MyBackgroundSubstraction(Mat matBackground, Mat matCurrent, int threshold) {
	matCurrent = createGrayMat(matCurrent);
	Mat result = matBackground.clone();
	int sub, valueColor, i, j, k;
	for (i = 0; i < matBackground.rows; ++i) {
		for (j = 0; j < matBackground.cols; ++j) {
			Vec3b& rgbBackground = matBackground.at<Vec3b>(i, j);
			Vec3b& rgbCurrent = matCurrent.at<Vec3b>(i, j);
			Vec3b& rgbResult = result.at<Vec3b>(i, j);

			for (k = 0; k < 3; k++) {
				sub = rgbCurrent[k] - rgbBackground[k];
				if (sub < 0) sub = -sub;
				if (sub > threshold) {
					rgbResult[k] = 255;
				}
				else
				{
					rgbResult[k] = 0;
				}
			}
		}
	}
	return result;
}

int cntCounting = 0;
int arrCounting[1281][1281][256];

void Init() {
	int i;
	for (i = 0; i < 256; i++) {
		//arrCounting[i] = 0;
	}
}

Mat MyBackgroundSubstraction_Update(Mat matBackground, Mat &matBackgroundUpdate, Mat matCurrent, int threshold, double alpha) {
	matCurrent = createGrayMat(matCurrent);
	Mat result = matBackground.clone();
	int sub, valueColor, i, j, k, m;
	for (i = 0; i < matBackground.rows; ++i) {
		for (j = 0; j < matBackground.cols; ++j) {
			Vec3b& rgbBackground = matBackground.at<Vec3b>(i, j);
			Vec3b& rgbCurrent = matCurrent.at<Vec3b>(i, j);
			Vec3b& rgbResult = result.at<Vec3b>(i, j);
			Vec3b& rgbBackgroundUpdate = matBackgroundUpdate.at<Vec3b>(i, j);
			
			for (k = 0; k < 3; k++) {
				// Background Substraction
				sub = rgbCurrent[k] - rgbBackground[k];
				if (sub < 0) sub = -sub;
				if (sub > threshold) {
					rgbResult[k] = 255;
					//Update Background: B(x, y,t) = α * B(x, y,t − 1) + (1 − α)* I(x, y,t)
					//rgbBackgroundUpdate[k] = (double)1 / alpha* rgbBackground[k] + (1 - (double)1 / alpha) * rgbCurrent[k];
					//rgbBackgroundUpdate[k] = (1 - (double)1 / alpha) * rgbBackground[k] + (double)1 / alpha * rgbCurrent[k];
				}
				else
				{
					rgbResult[k] = 0;
					//Update Background: B(x, y,t) = (1 − α)B(x, y,t − 1) + αI(x, y,t)
					//rgbBackgroundUpdate[k] = (1 - (double)1 / alpha) * rgbBackground[k] + (double)1 / alpha * rgbCurrent[k];
					//rgbBackgroundUpdate[k] = (double)1 / alpha* rgbBackground[k] + (1 - (double)1 / alpha) * rgbCurrent[k];
				}
				// Update Background: B(x, y,t) = (1 − α)B(x, y,t − 1) + αI(x, y,t)
				//rgbBackgroundUpdate[k] = (1 - (double)1 / alpha) * rgbBackground[k] + (double)1 / alpha * rgbCurrent[k];
				rgbBackgroundUpdate[k] = (1 - alpha) * rgbBackground[k] + alpha * rgbCurrent[k];
				// Update threshold: 
				
			}
		}
	}
	return result;
}


int findBiggestContour(vector<vector<Point> > contours)
{
	int indexOfBiggestContour = -1;
	int sizeOfBiggestContour = 0;

	for (int i = 0; i < contours.size(); i++) {
		if (contours[i].size() > sizeOfBiggestContour) {
			sizeOfBiggestContour = contours[i].size();
			indexOfBiggestContour = i;
		}
	}
	return indexOfBiggestContour;
}

int main(int argc, char* argv[])
{
	//create GUI windows
	namedWindow("Frame");
	////namedWindow("Gray video", CV_WINDOW_AUTOSIZE);
	//namedWindow("Backgroung Update");
	//namedWindow("Backgroung subtraction");

	//namedWindow("Canny");
	//namedWindow("Erode");
	//namedWindow("Dialate");
	

	//processVideo("F:\\Hoc_Tap\\2018-2019\\Do an tot nghiep\\2018\\video\\my_flycam_3.mp4");
	processVideo("F:\\Hoc_Tap\\2018-2019\\Do an tot nghiep\\2018\\video\\flycam1.mp4");
	//processVideo("F:\\Hoc_Tap\\2018-2019\\Do an tot nghiep\\2018\\video\\flycam2.mp4");
	//processVideo("F:\\Hoc_Tap\\2018-2019\\Do an tot nghiep\\2018\\video\\flycam3.mp4");
	//processVideo("F:\\Hoc_Tap\\2018-2019\\Do an tot nghiep\\2018\\video\\flycam4.mp4");
	
	 //processVideo("F:\\Hoc_Tap\\2018-2019\\Do an tot nghiep\\2018\\video\\flycam3.avi");

	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}
void processVideo(char* videoFilename) {
	//create the capture object
	VideoCapture capture(videoFilename);
	//VideoCapture capture(0);

	if (!capture.isOpened()) {
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}
	//read input data. ESC or 'q' for quitting
	keyboard = 0;
	int dem = 0;
	//int threshold;

	Mat frameBefore;
	while (keyboard != 'q' && keyboard != 27) {
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}
		// - --------------------------------- My Solve ---------------------------//

		Mat frameSub;
		capture >> frame; // get a new frame from camera
		if (dem == 0) {
			matBackground = createGrayMat(frame.clone());
			frameSub = MyBackgroundSubstraction(matBackground, frame.clone(), 35);
		}
		else {
			// flycam1
			_threshold = 60;
			_alpha = 0.1;

			//// flycam2, 3
			//_threshold = 65;
			//_alpha = 0.1;

			//// flycam4
			//_threshold = 65;
			//_alpha = 0.6;

			frameSub = MyBackgroundSubstraction_Update(matBackground, matBackground, frame.clone(), _threshold, _alpha);


			//////////////////////////////// khoanh vung ////////////////////////////////////////////////

			////createTrackbar(" Canny thresh:", "Source", &thresh, max_thresh, thresh_callback);
			//Mat canny_output;
			//vector<vector<Point> > contours;
			//vector<Vec4i> hierarchy;

			//Mat Erode(frameSub.size(), CV_8UC1);
			////Video 1
			//cv::erode(frameSub, Erode, cv::Mat(), cv::Point(-1, -1), 1);
			//// Video 2
			////cv::erode(frameSub, Erode, cv::Mat(), cv::Point(-1, -1), 1);
			////imshow("Erode", Erode);
			//Mat Dialate(frameSub.size(), CV_8UC1);
			//cv::dilate(Erode, Dialate, cv::Mat(), cv::Point(-1, -1), 2);
			////imshow("Dialate", Dialate);

			///// Detect edges using canny
			//Canny(Dialate, canny_output, thresh, thresh * 2, 3);
			////imshow("Canny", canny_output);

			///// Find contours
			//findContours(canny_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));

			///// Draw contours
			//Mat drawing = Mat::zeros(canny_output.size(), CV_8UC3);

			//for (int i = 0; i< contours.size(); i++)
			//{
			//	//Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			//	drawContours(frame, contours, i, CV_RGB(255, 0, 0), 1, 8, hierarchy, 0, Point());
			//	//drawContours(drawing, contours, i, CV_RGB(255, 0, 0), 1, 8, hierarchy, 0, Point());
			//}

			///// Show in a window
			////imshow("Backgroung subtraction", drawing);
			//imshow("Frame", frame);

			////////////////////////////////////////////////////////////////////////////////////////////////


			vector<Vec4i> hierarchy;
			vector<vector<cv::Point> > contours_hull;


			Mat Erode(frameSub.size(), CV_8UC1);
			cv::erode(frameSub, Erode, cv::Mat(), cv::Point(-1, -1));
			Mat Dialate(frameSub.size(), CV_8UC1);
			cv::dilate(Erode, Dialate, cv::Mat(), cv::Point(-1, -1), 2);
			///// Detect edges using canny
			Mat canny_output;
			Canny(frameSub, canny_output, thresh, thresh * 2, 3);
			findContours(canny_output, contours_hull, hierarchy, CV_RETR_TREE, CV_CLOCKWISE, cv::Point(0, 0)); // CV_CHAIN_APPROX_SIMPLE

			Mat drawing = Mat::zeros(frameSub.size(), CV_8UC3);
			if (contours_hull.size() > 0) {
				/// Find the convex hull object for each contour
				vector<vector<cv::Point> >hull(contours_hull.size());
				//find the defects points for each contour
				vector<vector<Vec4i>> defects(contours_hull.size());

				//vector<vector<int> > hullsI(contours_hull.size());

				//find the biggest contour
				IndexOfBiggestContour = findBiggestContour(contours_hull);

				//Point2f rect_points[4];
				//vector<RotatedRect> minRect(contours_hull.size());

				vector<vector<cv::Point> > contours_poly(contours_hull.size());
				vector<Rect> boundRect(contours_hull.size());

				for (int i = 0; i < contours_hull.size(); i++)
				{
					convexHull(Mat(contours_hull[i]), hull[i], false);
					/*convexHull(Mat(contours_hull[i]), hullsI[i], false);
					convexityDefects(Mat(contours_hull[i]), hullsI[i], defects[i]);*/

					if (IndexOfBiggestContour == i)
					{
						//minRect[i] = minAreaRect(Mat(contours_hull[i]));
						approxPolyDP(Mat(contours_hull[i]), contours_poly[i], 3, true);
						boundRect[i] = boundingRect(Mat(contours_poly[i]));

						
						int h = boundRect[i].height;
						int w = boundRect[i].width;
						if (h < w) {
							h = boundRect[i].width;
							w = boundRect[i].height;
						}
						int area = boundRect[i].area();

						double ty_le = (double)h / (double)w;
						double ty_le_chuan = (double)8 / (double)3;

						if (area >= 50 && ty_le <= ty_le_chuan) {
							rectangle(frame, boundRect[i].tl(), boundRect[i].br(), CV_RGB(255, 255, 0), 2, 1, 0);
						}
						//rectangle(frame, boundRect[i].tl(), boundRect[i].br(), CV_RGB(255, 0, 0), 1, 1, 0);
					}
				}
			}
			//imshow("Backgroung subtraction", drawing);
			imshow("Frame", frame);


		}

		dem++;

		// ----------------------------------------------------------------------- //

		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20), cv::Scalar(255, 255, 255), -1);
		ss << capture.get(CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
		//show the current frame and the fg masks
		imshow("Frame", frame);

		//imshow("Backgroung Update", matBackground);

		////imshow("Gray video", frame22);
		//imshow("Backgroung subtraction", frameSub);
		//get the input from the keyboard
		keyboard = (char)waitKey(30);
	}
	//delete capture object
	capture.release();
}
